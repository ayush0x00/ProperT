pragma solidity ^0.8.0;

import "../MintingContracts/MintLand.sol";
import "../MintingContracts/MintLord.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract Rental{
    using SafeMath for uint256;
    address owner;
    LandNFT landNFTContract; //instance of landNFT from MintLand.sol
    LordNFT lordNFTContract;    //instance of lordNFT from MintLord.sol
    mapping(address => mapping(uint256 => uint256)) landLastReedemedTime; //mapping from (user address =>(landId => landRedeemedTime))
    mapping(address => mapping(uint256 => uint8)) landsRedeemedByLord;  //mapping from (user => (lordId => number of lands redeemed by lord))
    mapping(address => uint256[3]) landsPerLord;  // number of lands of each type a user holds. [type1, type2, type3]
    uint256 amountToBeDistributed; //total amount received which is to be distributed as rent
    constructor (address _landNFT, address _lordNFT){
        owner=msg.sender;
        landNFTContract = LandNFT(payable(_landNFT));
        lordNFTContract = LordNFT(payable(_lordNFT));    
    }

    receive() external payable {}
    
    function transferAmount(address payable _to, uint256 amnt) public payable{
        (bool sent, bytes memory data) = _to.call{value: amnt}("");
        require (sent, "Failed to send amount");
    }

// Given a land id, returns per day rent generated by the land
    function getEachDayRent(uint256 landTokenId) public view returns(uint256){ 
        uint8 typeOfLand = landNFTContract.tokenIdToLandType(landTokenId);
        uint256 weight = getWeightOfLand(typeOfLand);
        return weight.mul(amountToBeDistributed).div(landNFTContract.numberOfMints(typeOfLand-1));
    }

    function _max(uint256 a, uint256 b) private pure returns(uint256){
        return (a > b ? a : b);
    }

// returns total rent available for user for the particular land using the particular lord
    function getTotalRent(address user, uint256 landTokenId, uint256 lordTokenId) public view returns(uint256){
        uint256 landBuyTime = landNFTContract.landBoughtAt(landTokenId);
        uint256 lordBuyTime = lordNFTContract.lordBoughtAt(lordTokenId);
        uint256 _startTimeForRent =  _max(landBuyTime,lordBuyTime).sub(landLastReedemedTime[user][landTokenId]);
        uint256 totalRentDays = block.timestamp.sub(_startTimeForRent).div(1 days);
        return totalRentDays.mul(getEachDayRent(landTokenId));
    }

// Allows user to withdraw rent for a particular land associated with a particular lord.
// The rent rent can be withdrawn only after 30 days from previous withdrawal.
    function withdrawRent(uint256 landTokenId, uint256 lordTokenId) public payable{
        require(msg.sender == landNFTContract.ownerOf(landTokenId) && msg.sender == lordNFTContract.ownerOf(lordTokenId));
        uint8 lordType = lordNFTContract.tokenIdToLordType(lordTokenId);

        // checks whether 30 days has been elapsed or not from previous withdrawal
        if(block.timestamp.sub(landLastReedemedTime[msg.sender][landTokenId]) < 30 days){
            //number of lands user can rent by a particular lord should be less than the lord rental limit.
            require(landsRedeemedByLord[msg.sender][lordTokenId] < lordNFTContract.maxLordRentLimit(lordType));
        }
        else{
            // if it has been more than 30 days, the user looses his rents generated
            landsRedeemedByLord[msg.sender][lordTokenId] = 0;
        }
        landsRedeemedByLord[msg.sender][lordTokenId] += 1;
        uint256 rent = getTotalRent(msg.sender, landTokenId, lordTokenId);
        transferAmount(payable(msg.sender), rent);
        landsPerLord[msg.sender][lordType-1] -= 1;
        //update last reedemed time
        landLastReedemedTime[msg.sender][landTokenId] = block.timestamp;
    }

// given the type of land, returns the weight of the particular land
    function getWeightOfLand(uint256 typeOfLand) public view returns(uint256){
        uint256 sumWeightMintProd = 0;
        for(uint8 i=0; i<3; i++){
            sumWeightMintProd += landNFTContract.costOfLand(i).mul(landNFTContract.numberOfMints(i));
        }

        return landNFTContract.costOfLand(typeOfLand-1).div(sumWeightMintProd);
    }

    function rentToDistribute() public payable{
        require(msg.sender == owner);
        amountToBeDistributed = msg.value;
    }

}